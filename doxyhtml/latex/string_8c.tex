\hypertarget{string_8c}{}\section{/home/loudish/mpx-\/spring2017-\/modestus/mpx\+\_\+core/lib/string.c File Reference}
\label{string_8c}\index{/home/loudish/mpx-\/spring2017-\/modestus/mpx\+\_\+core/lib/string.\+c@{/home/loudish/mpx-\/spring2017-\/modestus/mpx\+\_\+core/lib/string.\+c}}
{\ttfamily \#include $<$system.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
Include dependency graph for string.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{string_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{string_8c_a2dee044e4e667b5b789b493abd21cfa4}{strlen} (const char $\ast$s)
\begin{DoxyCompactList}\small\item\em strlen returns the length of a string \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{string_8c_a1eb9cae61e6a6282c28dbc298ef7297e}{strcpy} (char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strcpy copies one string to another string \end{DoxyCompactList}\item 
int \hyperlink{string_8c_a30670a60464f77af17dfb353353d6df8}{atoi} (const char $\ast$s)
\begin{DoxyCompactList}\small\item\em atoi converts and A\+S\+C\+II string to an integer \end{DoxyCompactList}\item 
int \hyperlink{string_8c_a11bd144d7d44914099a3aeddf1c8567d}{strcmp} (const char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strcmp compares two strings. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{string_8c_a8908188ae9fc2f05d993257ef001d553}{strcat} (char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strcat concatenates the contents of one string onto another. \end{DoxyCompactList}\item 
int \hyperlink{string_8c_a0f3d37d605e9e6d4fc1853ff9d4b91bf}{isspace} (const char $\ast$c)
\begin{DoxyCompactList}\small\item\em isspace Determines if a character is a whitespace. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{string_8c_ace6ee45c30e71865e6eb635200379db9}{memset} (void $\ast$s, int c, \hyperlink{system_8h_a7c94ea6f8948649f8d181ae55911eeaf}{size\+\_\+t} n)
\begin{DoxyCompactList}\small\item\em memset Set a region of memory. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{string_8c_af1a867dcea42fc1215d0eddf19283ef3}{strtok} (char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strtok Split string into tokens. \end{DoxyCompactList}\item 
int \hyperlink{string_8c_a4adae2826c898e6fded351cfebc561b4}{\+\_\+\+\_\+attribute\+\_\+\+\_\+} ((format(\hyperlink{string_8h_a0f459d16901ef591acaafa4b67fd4be5}{printf}, 3, 4)))
\begin{DoxyCompactList}\small\item\em sprintf print with format to specified string buffer \end{DoxyCompactList}\item 
int \hyperlink{string_8c_a397a240a4a5dc802bd2ba2054d25ae15}{int\+ToS} (const int $\ast$const i, char $\ast$buf, int buf\+Length)
\begin{DoxyCompactList}\small\item\em int\+ToS converts a signed integer to string \end{DoxyCompactList}\item 
char \hyperlink{string_8c_aca5e96bcd4ba56fb4d7ac75160f2161c}{is\+\_\+conversion\+\_\+specifier} (char c)
\begin{DoxyCompactList}\small\item\em is\+\_\+conversion\+\_\+specifier checks to see if the character is one of the standard printf formats \end{DoxyCompactList}\item 
int \hyperlink{string_8c_a1153bdbe1c0758a66d46bdefa2eb755d}{isnum} (const char c)
\begin{DoxyCompactList}\small\item\em isnum inline helper function to check if a character is represents an ascii number \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{string.\+c@{string.\+c}!\+\_\+\+\_\+attribute\+\_\+\+\_\+@{\+\_\+\+\_\+attribute\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+attribute\+\_\+\+\_\+@{\+\_\+\+\_\+attribute\+\_\+\+\_\+}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{\+\_\+\+\_\+attribute\+\_\+\+\_\+((format(printf, 3, 4)))}{__attribute__((format(printf, 3, 4)))}}]{\setlength{\rightskip}{0pt plus 5cm}int \+\_\+\+\_\+attribute\+\_\+\+\_\+ (
\begin{DoxyParamCaption}
\item[{(format({\bf printf}, 3, 4))}]{}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a4adae2826c898e6fded351cfebc561b4}{}\label{string_8c_a4adae2826c898e6fded351cfebc561b4}


sprintf print with format to specified string buffer 


\begin{DoxyParams}{Parameters}
{\em str} & a char $\ast$, place where the built string will be placed \\
\hline
{\em buf\+Length} & the size of the buffer of the char $\ast$, string writing will not exceed this value \\
\hline
{\em format} & a format string confirming to the std library format \\
\hline
{\em ...} & any number of parameters that will be printed according to the format. if wrong type is specified, behavior is undefined \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of characters placed in the output buffer 
\end{DoxyReturn}


Definition at line 225 of file string.\+c.



References arg\+\_\+list, atoi(), init\+\_\+arg\+\_\+list, int\+To\+S(), is\+\_\+conversion\+\_\+specifier(), isnum(), strcpy(), and strlen().


\begin{DoxyCode}
226 \{ 
227 
228     \textcolor{keywordflow}{if}(!str || bufLength <= 0) \{
229      \textcolor{keywordflow}{return} 0;
230     \}
231 
232     \hyperlink{arg__list_8h_abb821de0a9df92f33d827f2008093ddc}{arg\_list} list;
233     \hyperlink{arg__list_8h_a65f99a627ef400f9d875acca35dbac69}{init\_arg\_list}(list, format);
234 
235     \textcolor{keywordtype}{int} newStrIndex = 0;
236     \textcolor{keywordtype}{int} index, formatLength = \hyperlink{string_8c_a2dee044e4e667b5b789b493abd21cfa4}{strlen}(format);
237     \textcolor{keywordflow}{for}(index = 0; format[index] != \textcolor{charliteral}{'\(\backslash\)0'} && index < formatLength; index++)
238     \{
239      
240      \textcolor{comment}{//flag is -1 until fulfilled, flag is 0 if not requested}
241         \textcolor{keywordflow}{if}(format[index] == \textcolor{charliteral}{'%'})
242         \{
243             \textcolor{keywordtype}{char} leftJustified=0, alwaysAppendSign=0, subSignWithSpace=0, altForm=0, padWithZeros=0;
244             \textcolor{keywordtype}{int} minFieldWidth=0, precision=0;
245             (void)padWithZeros;
246             \textcolor{keywordflow}{for}(; !\hyperlink{string_8c_aca5e96bcd4ba56fb4d7ac75160f2161c}{is\_conversion\_specifier}(format[index]); index++)
247             \{
248                 \textcolor{keywordflow}{if}(format[index]==\textcolor{charliteral}{'\(\backslash\)0'})
249                 \{
250                     \textcolor{keywordflow}{return} 0; \textcolor{comment}{//if we reach the end of the string, exit as the format is missing}
251                 \}
252                 \textcolor{keywordflow}{if}(!minFieldWidth && !precision)
253                 \{
254                     \textcolor{keywordflow}{switch}(format[index])
255                     \{           
256                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'-'}: leftJustified=1; \textcolor{keywordflow}{break};
257                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}: \textcolor{keywordflow}{if}(!leftJustified) \{alwaysAppendSign=1;\} \textcolor{keywordflow}{break};
258                         \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}: \textcolor{keywordflow}{if}(!leftJustified && !alwaysAppendSign)\{subSignWithSpace=1;\} \textcolor{keywordflow}{break};
259                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'#'}: \textcolor{keywordflow}{if}(!leftJustified && !alwaysAppendSign && !subSignWithSpace) \{altForm=1;\}
       \textcolor{keywordflow}{break};
260                         \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}: \textcolor{keywordflow}{if}(!leftJustified && !alwaysAppendSign && !subSignWithSpace && !altForm)\{
      padWithZeros=1;\} \textcolor{keywordflow}{break};
261                     \}
262                 \}
263                 \textcolor{keywordflow}{if}(format[index] == \textcolor{charliteral}{'.'})\{ precision = -1;\}
264                 \textcolor{keywordflow}{if}(\hyperlink{string_8c_a1153bdbe1c0758a66d46bdefa2eb755d}{isnum}(format[index])) \textcolor{comment}{//implement the * modifier here}
265                 \{
266                     \textcolor{keywordflow}{if}(precision==-1)
267                     \{ 
268                         precision = \hyperlink{string_8c_a30670a60464f77af17dfb353353d6df8}{atoi}(&format[index]); 
269                     \}
270                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(!minFieldWidth) 
271                     \{ 
272                         minFieldWidth = \hyperlink{string_8c_a30670a60464f77af17dfb353353d6df8}{atoi}(&format[index]); 
273                     \}
274                 \}
275             \}\textcolor{comment}{//finished parsing one conversion   }
276             \textcolor{comment}{//need to implement all modifiers}
277             \textcolor{keywordflow}{if}(format[index]==\textcolor{charliteral}{'d'})
278             \{
279                 newStrIndex += \hyperlink{string_8c_a397a240a4a5dc802bd2ba2054d25ae15}{intToS}((\textcolor{keywordtype}{int}*)next\_arg\_in\_list(&list, &format[index], 0), &str[
      newStrIndex], bufLength-newStrIndex) - 1;
280             \}
281             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(format[index]==\textcolor{charliteral}{'c'})
282             \{
283                 str[newStrIndex]= **((\textcolor{keywordtype}{char}**)next\_arg\_in\_list(&list, &format[index], 0));
284                 newStrIndex++;
285             \}
286             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(format[index]==\textcolor{charliteral}{'s'})
287             \{
288                 \textcolor{keywordtype}{char} *strToCopy = *((\textcolor{keywordtype}{char}**)next\_arg\_in\_list(&list, &format[index], 0));
289                 \textcolor{keywordtype}{int} lengthOfCopy = \hyperlink{string_8c_a2dee044e4e667b5b789b493abd21cfa4}{strlen}(strToCopy);
290                 \hyperlink{string_8c_a1eb9cae61e6a6282c28dbc298ef7297e}{strcpy}(&str[newStrIndex], strToCopy);
291                 newStrIndex += lengthOfCopy-1;
292             \}
293         \}
294         \textcolor{keywordflow}{else}
295         \{
296             str[newStrIndex] = format[index];
297             newStrIndex++;
298         \}
299     \}
300     str[newStrIndex]=0;
301     \textcolor{keywordflow}{return} newStrIndex;
302 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!atoi@{atoi}}
\index{atoi@{atoi}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{atoi(const char $\ast$s)}{atoi(const char *s)}}]{\setlength{\rightskip}{0pt plus 5cm}int atoi (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a30670a60464f77af17dfb353353d6df8}{}\label{string_8c_a30670a60464f77af17dfb353353d6df8}


atoi converts and A\+S\+C\+II string to an integer 


\begin{DoxyParams}{Parameters}
{\em s} & const char $\ast$s, character pointer to a string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the integer value of s. 
\end{DoxyReturn}


Definition at line 45 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+(), kmain(), set\+Date(), and set\+Time().


\begin{DoxyCode}
46 \{
47     \textcolor{keywordtype}{int} num = 0;
48     \textcolor{keywordflow}{if}(!s)
49     \{
50         \textcolor{keywordflow}{return} 0;
51     \}
52 
53     \textcolor{keywordtype}{int} isNeg = ( *s == \textcolor{charliteral}{'-'});
54     \textcolor{keywordflow}{while}((*s >= \textcolor{charliteral}{'0'}) && (*s <= \textcolor{charliteral}{'9'} ))
55     \{
56         num = (num*10) + (*s - \textcolor{charliteral}{'0'});
57         s++;
58     \}
59     \textcolor{keywordflow}{if}(isNeg)
60     \{
61         num = num *(-1);
62     \}
63 
64     \textcolor{keywordflow}{return} num; \textcolor{comment}{// return integer}
65 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!int\+ToS@{int\+ToS}}
\index{int\+ToS@{int\+ToS}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{int\+To\+S(const int $\ast$const i, char $\ast$buf, int buf\+Length)}{intToS(const int *const i, char *buf, int bufLength)}}]{\setlength{\rightskip}{0pt plus 5cm}int int\+ToS (
\begin{DoxyParamCaption}
\item[{const int $\ast$const}]{i, }
\item[{char $\ast$}]{buf, }
\item[{int}]{buf\+Length}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a397a240a4a5dc802bd2ba2054d25ae15}{}\label{string_8c_a397a240a4a5dc802bd2ba2054d25ae15}


int\+ToS converts a signed integer to string 


\begin{DoxyParams}{Parameters}
{\em i} & integer to convert \\
\hline
{\em buf} & buf to place the converted string \\
\hline
{\em buf\+Length} & length of the buffer, string writing will not exceed this value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
num of characters written to buffer 
\end{DoxyReturn}


Definition at line 313 of file string.\+c.



References strlen().



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+().


\begin{DoxyCode}
314 \{
315     \textcolor{keywordflow}{if}(!buf)
316     \{ 
317         \textcolor{keywordflow}{return} 0; 
318     \}
319     
320     \textcolor{keywordtype}{int} cpy=*i;
321     \textcolor{keywordtype}{int} length = 1;
322     \textcolor{keywordflow}{if}(*i < 0)
323     \{ 
324         cpy*=-1;
325         length++;
326     \}
327     
328     \textcolor{keywordflow}{do}\{
329         length++;
330     \}\textcolor{keywordflow}{while}((cpy/=10)); \textcolor{comment}{//find total length of string}
331     
332     \textcolor{keywordflow}{if}(bufLength<length+1) \textcolor{comment}{//if the bufLength is less than the length+null term, return 0}
333     \{
334         \textcolor{keywordflow}{return} 0;
335     \}
336             
337     cpy=(*i<0)?(*i) * -1: *i;      \textcolor{comment}{//reset val copy}
338     length--;
339     buf[length]=\textcolor{charliteral}{'\(\backslash\)0'}; \textcolor{comment}{//insert null terminator at end of string}
340     length--;
341     \textcolor{keywordflow}{for}(; length >= 0; length--) \textcolor{comment}{//convert int to char and copy into buffer backwards}
342     \{
343         buf[length] = cpy%10 + \textcolor{charliteral}{'0'}; 
344         cpy/=10;
345     \}
346     \textcolor{keywordflow}{if}(*i<0)
347     \{
348         buf[0]=\textcolor{charliteral}{'-'};
349     \}
350     
351     \textcolor{keywordflow}{return} \hyperlink{string_8c_a2dee044e4e667b5b789b493abd21cfa4}{strlen}(buf);
352 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!is\+\_\+conversion\+\_\+specifier@{is\+\_\+conversion\+\_\+specifier}}
\index{is\+\_\+conversion\+\_\+specifier@{is\+\_\+conversion\+\_\+specifier}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{is\+\_\+conversion\+\_\+specifier(char c)}{is_conversion_specifier(char c)}}]{\setlength{\rightskip}{0pt plus 5cm}char is\+\_\+conversion\+\_\+specifier (
\begin{DoxyParamCaption}
\item[{char}]{c}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_aca5e96bcd4ba56fb4d7ac75160f2161c}{}\label{string_8c_aca5e96bcd4ba56fb4d7ac75160f2161c}


is\+\_\+conversion\+\_\+specifier checks to see if the character is one of the standard printf formats 


\begin{DoxyParams}{Parameters}
{\em c} & character to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns the character if the character is a format specifier, else returns 0 
\end{DoxyReturn}


Definition at line 359 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+().


\begin{DoxyCode}
360 \{
361     \textcolor{keywordflow}{switch}(c)
362     \{
363         \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}: 
364         \textcolor{keywordflow}{case} \textcolor{charliteral}{'s'}: 
365         \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}: 
366         \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'o'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'X'}: 
367         \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'}: \textcolor{keywordflow}{case}\textcolor{charliteral}{'A'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'g'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'G'}:
368         \textcolor{keywordflow}{case} \textcolor{charliteral}{'p'}: 
369             \textcolor{keywordflow}{return} c; 
370         
371         \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 0;
372     \}
373     \textcolor{keywordflow}{return} 0;
374 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!isnum@{isnum}}
\index{isnum@{isnum}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{isnum(const char c)}{isnum(const char c)}}]{\setlength{\rightskip}{0pt plus 5cm}int isnum (
\begin{DoxyParamCaption}
\item[{const char}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{string_8c_a1153bdbe1c0758a66d46bdefa2eb755d}{}\label{string_8c_a1153bdbe1c0758a66d46bdefa2eb755d}


isnum inline helper function to check if a character is represents an ascii number 


\begin{DoxyParams}{Parameters}
{\em c} & character to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns 1 if the character is an ascii number, else returns 0 
\end{DoxyReturn}


Definition at line 381 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+().


\begin{DoxyCode}
382 \{
383    \textcolor{keywordflow}{return} ((c >= \textcolor{charliteral}{'0'}) && (c <= \textcolor{charliteral}{'9'}));
384 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!isspace@{isspace}}
\index{isspace@{isspace}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{isspace(const char $\ast$c)}{isspace(const char *c)}}]{\setlength{\rightskip}{0pt plus 5cm}int isspace (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{c}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a0f3d37d605e9e6d4fc1853ff9d4b91bf}{}\label{string_8c_a0f3d37d605e9e6d4fc1853ff9d4b91bf}


isspace Determines if a character is a whitespace. 


\begin{DoxyParams}{Parameters}
{\em c} & character to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if it is a whitespace, 0 if it is not a whitespace. 
\end{DoxyReturn}


Definition at line 110 of file string.\+c.


\begin{DoxyCode}
111 \{
112   \textcolor{keywordflow}{if} (*c == \textcolor{charliteral}{' '}  ||
113       *c == \textcolor{charliteral}{'\(\backslash\)n'} ||
114       *c == \textcolor{charliteral}{'\(\backslash\)r'} ||
115       *c == \textcolor{charliteral}{'\(\backslash\)f'} ||
116       *c == \textcolor{charliteral}{'\(\backslash\)t'} ||
117       *c == \textcolor{charliteral}{'\(\backslash\)v'})\{
118     \textcolor{keywordflow}{return} 1;
119   \}
120   \textcolor{keywordflow}{return} 0;
121 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!memset@{memset}}
\index{memset@{memset}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{memset(void $\ast$s, int c, size\+\_\+t n)}{memset(void *s, int c, size_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ memset (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{s, }
\item[{int}]{c, }
\item[{{\bf size\+\_\+t}}]{n}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_ace6ee45c30e71865e6eb635200379db9}{}\label{string_8c_ace6ee45c30e71865e6eb635200379db9}


memset Set a region of memory. 


\begin{DoxyParams}{Parameters}
{\em s} & destination. \\
\hline
{\em c} & byte to write. \\
\hline
{\em n} & count. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}


Definition at line 135 of file string.\+c.



Referenced by init\+\_\+idt(), and init\+\_\+paging().


\begin{DoxyCode}
136 \{
137   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) s;
138   \textcolor{keywordflow}{while}(n--)\{
139     *p++ = (\textcolor{keywordtype}{unsigned} char) c;
140   \}
141   \textcolor{keywordflow}{return} s;
142 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!strcat@{strcat}}
\index{strcat@{strcat}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{strcat(char $\ast$s1, const char $\ast$s2)}{strcat(char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ strcat (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a8908188ae9fc2f05d993257ef001d553}{}\label{string_8c_a8908188ae9fc2f05d993257ef001d553}


strcat concatenates the contents of one string onto another. 


\begin{DoxyParams}{Parameters}
{\em s1} & destination string. \\
\hline
{\em s2} & source string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The combined string s1 and s2. 
\end{DoxyReturn}


Definition at line 97 of file string.\+c.



Referenced by klogv(), kmain(), and kpanic().


\begin{DoxyCode}
98 \{
99   \textcolor{keywordtype}{char} *rc = s1;
100   \textcolor{keywordflow}{if} (*s1) \textcolor{keywordflow}{while}(*++s1);
101   \textcolor{keywordflow}{while}( (*s1++ = *s2++) );
102   \textcolor{keywordflow}{return} rc;
103 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!strcmp@{strcmp}}
\index{strcmp@{strcmp}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{strcmp(const char $\ast$s1, const char $\ast$s2)}{strcmp(const char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}int strcmp (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a11bd144d7d44914099a3aeddf1c8567d}{}\label{string_8c_a11bd144d7d44914099a3aeddf1c8567d}


strcmp compares two strings. 


\begin{DoxyParams}{Parameters}
{\em s1} & string 1 to compare. \\
\hline
{\em s2} & string 2 to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
if the two strings are equal. If they are equal it will return 0, otherwise will return a non-\/zero integer. 
\end{DoxyReturn}


Definition at line 73 of file string.\+c.



Referenced by date(), exec\+\_\+comm(), help\+Date(), help\+Func(), help\+Time(), is\+Empty(), pcb\+Func(), pcb\+Search\+Func(), searchcomp\+Function(), string\+To\+Class(), and time().


\begin{DoxyCode}
74 \{
75 
76   \textcolor{comment}{// Remarks:}
77   \textcolor{comment}{// 1) If we made it to the end of both strings (i. e. our pointer points to a}
78   \textcolor{comment}{//    '\(\backslash\)0' character), the function will return 0}
79   \textcolor{comment}{// 2) If we didn't make it to the end of both strings, the function will}
80   \textcolor{comment}{//    return the difference of the characters at the first index of}
81   \textcolor{comment}{//    indifference.}
82   \textcolor{keywordtype}{int} i = 0;
83   \textcolor{keywordflow}{for}(; (s1[i]) && (s2[i]) && (s1[i]==s2[i]); i++)
84   \{
85   \}
86   
87   \textcolor{keywordflow}{return} s1[i]-s2[i];
88 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!strcpy@{strcpy}}
\index{strcpy@{strcpy}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{strcpy(char $\ast$s1, const char $\ast$s2)}{strcpy(char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ strcpy (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a1eb9cae61e6a6282c28dbc298ef7297e}{}\label{string_8c_a1eb9cae61e6a6282c28dbc298ef7297e}


strcpy copies one string to another string 


\begin{DoxyParams}{Parameters}
{\em s1} & destination string. Character pointer to a string. \\
\hline
{\em s2} & source string. Character pointer to a string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return s1. 
\end{DoxyReturn}


Definition at line 26 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+(), init\+\_\+commhand(), parse\+\_\+comm(), serial\+\_\+poll(), and setup\+P\+C\+B().


\begin{DoxyCode}
27 \{
28   \textcolor{keywordflow}{while}(*s2 != \textcolor{charliteral}{'\(\backslash\)0'}) \{
29       *s1 = *s2;
30       s1++;
31       s2++;
32    \}
33    \textcolor{keywordflow}{if}(*s2 == \textcolor{charliteral}{'\(\backslash\)0'}) \{
34       
35       *s1 = *s2;
36    \}
37   \textcolor{keywordflow}{return} s1; \textcolor{comment}{// return pointer to destination string}
38 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!strlen@{strlen}}
\index{strlen@{strlen}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{strlen(const char $\ast$s)}{strlen(const char *s)}}]{\setlength{\rightskip}{0pt plus 5cm}int strlen (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_a2dee044e4e667b5b789b493abd21cfa4}{}\label{string_8c_a2dee044e4e667b5b789b493abd21cfa4}


strlen returns the length of a string 


\begin{DoxyParams}{Parameters}
{\em s} & character pointer to a string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the length of the string 
\end{DoxyReturn}


Definition at line 10 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+(), help\+Date(), help\+Time(), int\+To\+S(), set\+Date(), set\+Time(), and setup\+P\+C\+B().


\begin{DoxyCode}
11 \{
12    \textcolor{keywordtype}{int} length = 0;
13    \textcolor{keywordflow}{while}(s[length] != \textcolor{charliteral}{'\(\backslash\)0'}) \{
14     length++;
15    \}
16    length++;
17   \textcolor{keywordflow}{return} length; \textcolor{comment}{// return length of string}
18 \}
\end{DoxyCode}
\index{string.\+c@{string.\+c}!strtok@{strtok}}
\index{strtok@{strtok}!string.\+c@{string.\+c}}
\subsubsection[{\texorpdfstring{strtok(char $\ast$s1, const char $\ast$s2)}{strtok(char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ strtok (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8c_af1a867dcea42fc1215d0eddf19283ef3}{}\label{string_8c_af1a867dcea42fc1215d0eddf19283ef3}


strtok Split string into tokens. 


\begin{DoxyParams}{Parameters}
{\em s1} & String to split \\
\hline
{\em s2} & Delimeter. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
String split into delimeters. 
\end{DoxyReturn}


Definition at line 150 of file string.\+c.



References N\+U\+LL.



Referenced by parse\+\_\+comm().


\begin{DoxyCode}
151 \{
152   \textcolor{keyword}{static} \textcolor{keywordtype}{char} *tok\_tmp = \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
153   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = s2;
154 
155   \textcolor{comment}{//new string}
156   \textcolor{keywordflow}{if} (s1!=\hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})\{
157     tok\_tmp = s1;
158   \}
159   \textcolor{comment}{//old string cont'd}
160   \textcolor{keywordflow}{else} \{
161     \textcolor{keywordflow}{if} (tok\_tmp==\hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})\{
162       \textcolor{keywordflow}{return} \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
163     \}
164     s1 = tok\_tmp;
165   \}
166 
167   \textcolor{comment}{//skip leading s2 characters}
168   \textcolor{keywordflow}{while} ( *p && *s1 )\{
169     \textcolor{keywordflow}{if} (*s1==*p)\{
170       ++s1;
171       p = s2;
172       \textcolor{keywordflow}{continue};
173     \}
174     ++p;
175   \}
176 
177   \textcolor{comment}{//no more to parse}
178   \textcolor{keywordflow}{if} (!*s1)\{
179     \textcolor{keywordflow}{return} (tok\_tmp = \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
180   \}
181 
182   \textcolor{comment}{//skip non-s2 characters}
183   tok\_tmp = s1;
184   \textcolor{keywordflow}{while} (*tok\_tmp)\{
185     p = s2;
186     \textcolor{keywordflow}{while} (*p)\{
187       \textcolor{keywordflow}{if} (*tok\_tmp==*p++)\{
188     *tok\_tmp++ = \textcolor{charliteral}{'\(\backslash\)0'};
189     \textcolor{keywordflow}{return} s1;
190       \}
191     \}
192     ++tok\_tmp;
193   \}
194 
195   \textcolor{comment}{//end of string}
196   tok\_tmp = \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
197   \textcolor{keywordflow}{return} s1;
198 \}
\end{DoxyCode}
