\hypertarget{string_8h}{}\section{/home/loudish/mpx-\/spring2017-\/modestus/mpx\+\_\+core/include/string.h File Reference}
\label{string_8h}\index{/home/loudish/mpx-\/spring2017-\/modestus/mpx\+\_\+core/include/string.\+h@{/home/loudish/mpx-\/spring2017-\/modestus/mpx\+\_\+core/include/string.\+h}}
{\ttfamily \#include $<$system.\+h$>$}\\*
{\ttfamily \#include $<$arg\+\_\+list.\+h$>$}\\*
{\ttfamily \#include $<$core/serial.\+h$>$}\\*
Include dependency graph for string.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=300pt]{string_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{string_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{string_8h_a0f459d16901ef591acaafa4b67fd4be5}{printf}(format, ...)
\begin{DoxyCompactList}\small\item\em printf is simply a wrapper macro around sprintf with built in terminal print builtin needs to be a macro to pass on varidic function args. Uses the C Language B\+U\+I\+L\+T-\/\+IT macro to use marco varidic functionability. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{string_8h_a0f3d37d605e9e6d4fc1853ff9d4b91bf}{isspace} (const char $\ast$c)
\begin{DoxyCompactList}\small\item\em isspace Determines if a character is a whitespace. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{string_8h_ace6ee45c30e71865e6eb635200379db9}{memset} (void $\ast$s, int c, \hyperlink{system_8h_a7c94ea6f8948649f8d181ae55911eeaf}{size\+\_\+t} n)
\begin{DoxyCompactList}\small\item\em memset Set a region of memory. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{string_8h_a1eb9cae61e6a6282c28dbc298ef7297e}{strcpy} (char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strcpy copies one string to another string \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{string_8h_a8908188ae9fc2f05d993257ef001d553}{strcat} (char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strcat concatenates the contents of one string onto another. \end{DoxyCompactList}\item 
int \hyperlink{string_8h_a2dee044e4e667b5b789b493abd21cfa4}{strlen} (const char $\ast$s)
\begin{DoxyCompactList}\small\item\em strlen returns the length of a string \end{DoxyCompactList}\item 
int \hyperlink{string_8h_a11bd144d7d44914099a3aeddf1c8567d}{strcmp} (const char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strcmp compares two strings. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{string_8h_af1a867dcea42fc1215d0eddf19283ef3}{strtok} (char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em strtok Split string into tokens. \end{DoxyCompactList}\item 
int \hyperlink{string_8h_a30670a60464f77af17dfb353353d6df8}{atoi} (const char $\ast$s)
\begin{DoxyCompactList}\small\item\em atoi converts and A\+S\+C\+II string to an integer \end{DoxyCompactList}\item 
int \hyperlink{string_8h_a397a240a4a5dc802bd2ba2054d25ae15}{int\+ToS} (const int $\ast$const i, char $\ast$buf, int buf\+Length)
\begin{DoxyCompactList}\small\item\em int\+ToS converts a signed integer to string \end{DoxyCompactList}\item 
char \hyperlink{string_8h_aca5e96bcd4ba56fb4d7ac75160f2161c}{is\+\_\+conversion\+\_\+specifier} (char c)
\begin{DoxyCompactList}\small\item\em is\+\_\+conversion\+\_\+specifier checks to see if the character is one of the standard printf formats \end{DoxyCompactList}\item 
int \hyperlink{string_8h_a1153bdbe1c0758a66d46bdefa2eb755d}{isnum} (const char c)
\begin{DoxyCompactList}\small\item\em isnum inline helper function to check if a character is represents an ascii number \end{DoxyCompactList}\item 
int \hyperlink{string_8h_ae9cac82f3293a00d8ec8705a3fc5cf64}{sprintf} (char $\ast$str, int buf\+Length, const char $\ast$format,...) \hyperlink{string_8c_a4adae2826c898e6fded351cfebc561b4}{\+\_\+\+\_\+attribute\+\_\+\+\_\+}((format(\hyperlink{string_8h_a0f459d16901ef591acaafa4b67fd4be5}{printf}
\begin{DoxyCompactList}\small\item\em sprintf print with format to specified string buffer \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\index{string.\+h@{string.\+h}!printf@{printf}}
\index{printf@{printf}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{printf}{printf}}]{\setlength{\rightskip}{0pt plus 5cm}\#define printf(
\begin{DoxyParamCaption}
\item[{}]{format, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a0f459d16901ef591acaafa4b67fd4be5}{}\label{string_8h_a0f459d16901ef591acaafa4b67fd4be5}
{\bfseries Value\+:}
\begin{DoxyCode}
\{ \(\backslash\)
    char buf[500]; \hyperlink{string_8h_ae9cac82f3293a00d8ec8705a3fc5cf64}{\(\backslash\)}
\hyperlink{string_8h_ae9cac82f3293a00d8ec8705a3fc5cf64}{    sprintf}(buf, 500, format, \_\_VA\_ARGS\_\_); \hyperlink{serial_8h_a995827efcd4dcfb780c9fbb9645410a4}{\(\backslash\)}
\hyperlink{serial_8h_a995827efcd4dcfb780c9fbb9645410a4}{    serial\_print}(buf); \(\backslash\)
\} \(\backslash\)
\end{DoxyCode}


printf is simply a wrapper macro around sprintf with built in terminal print builtin needs to be a macro to pass on varidic function args. Uses the C Language B\+U\+I\+L\+T-\/\+IT macro to use marco varidic functionability. 



Definition at line 112 of file string.\+h.



Referenced by get\+Date(), kmain(), list\+Test(), pcb\+Func(), pcb\+Test(), print\+List(), print\+P\+C\+B\+Func(), set\+Date(), set\+Priority(), show\+All\+Processes(), show\+Blocked\+Processes(), show\+P\+C\+B(), show\+Ready\+Processes(), and test\+Print\+Func().



\subsection{Function Documentation}
\index{string.\+h@{string.\+h}!atoi@{atoi}}
\index{atoi@{atoi}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{atoi(const char $\ast$s)}{atoi(const char *s)}}]{\setlength{\rightskip}{0pt plus 5cm}int atoi (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a30670a60464f77af17dfb353353d6df8}{}\label{string_8h_a30670a60464f77af17dfb353353d6df8}


atoi converts and A\+S\+C\+II string to an integer 


\begin{DoxyParams}{Parameters}
{\em s} & const char $\ast$s, character pointer to a string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the integer value of s. 
\end{DoxyReturn}


Definition at line 45 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+(), kmain(), set\+Date(), and set\+Time().


\begin{DoxyCode}
46 \{
47     \textcolor{keywordtype}{int} num = 0;
48     \textcolor{keywordflow}{if}(!s)
49     \{
50         \textcolor{keywordflow}{return} 0;
51     \}
52 
53     \textcolor{keywordtype}{int} isNeg = ( *s == \textcolor{charliteral}{'-'});
54     \textcolor{keywordflow}{while}((*s >= \textcolor{charliteral}{'0'}) && (*s <= \textcolor{charliteral}{'9'} ))
55     \{
56         num = (num*10) + (*s - \textcolor{charliteral}{'0'});
57         s++;
58     \}
59     \textcolor{keywordflow}{if}(isNeg)
60     \{
61         num = num *(-1);
62     \}
63 
64     \textcolor{keywordflow}{return} num; \textcolor{comment}{// return integer}
65 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!int\+ToS@{int\+ToS}}
\index{int\+ToS@{int\+ToS}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{int\+To\+S(const int $\ast$const i, char $\ast$buf, int buf\+Length)}{intToS(const int *const i, char *buf, int bufLength)}}]{\setlength{\rightskip}{0pt plus 5cm}int int\+ToS (
\begin{DoxyParamCaption}
\item[{const int $\ast$const}]{i, }
\item[{char $\ast$}]{buf, }
\item[{int}]{buf\+Length}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a397a240a4a5dc802bd2ba2054d25ae15}{}\label{string_8h_a397a240a4a5dc802bd2ba2054d25ae15}


int\+ToS converts a signed integer to string 


\begin{DoxyParams}{Parameters}
{\em i} & integer to convert \\
\hline
{\em buf} & buf to place the converted string \\
\hline
{\em buf\+Length} & length of the buffer, string writing will not exceed this value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
num of characters written to buffer 
\end{DoxyReturn}


Definition at line 313 of file string.\+c.



References strlen().



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+().


\begin{DoxyCode}
314 \{
315     \textcolor{keywordflow}{if}(!buf)
316     \{ 
317         \textcolor{keywordflow}{return} 0; 
318     \}
319     
320     \textcolor{keywordtype}{int} cpy=*i;
321     \textcolor{keywordtype}{int} length = 1;
322     \textcolor{keywordflow}{if}(*i < 0)
323     \{ 
324         cpy*=-1;
325         length++;
326     \}
327     
328     \textcolor{keywordflow}{do}\{
329         length++;
330     \}\textcolor{keywordflow}{while}((cpy/=10)); \textcolor{comment}{//find total length of string}
331     
332     \textcolor{keywordflow}{if}(bufLength<length+1) \textcolor{comment}{//if the bufLength is less than the length+null term, return 0}
333     \{
334         \textcolor{keywordflow}{return} 0;
335     \}
336             
337     cpy=(*i<0)?(*i) * -1: *i;      \textcolor{comment}{//reset val copy}
338     length--;
339     buf[length]=\textcolor{charliteral}{'\(\backslash\)0'}; \textcolor{comment}{//insert null terminator at end of string}
340     length--;
341     \textcolor{keywordflow}{for}(; length >= 0; length--) \textcolor{comment}{//convert int to char and copy into buffer backwards}
342     \{
343         buf[length] = cpy%10 + \textcolor{charliteral}{'0'}; 
344         cpy/=10;
345     \}
346     \textcolor{keywordflow}{if}(*i<0)
347     \{
348         buf[0]=\textcolor{charliteral}{'-'};
349     \}
350     
351     \textcolor{keywordflow}{return} \hyperlink{string_8c_a2dee044e4e667b5b789b493abd21cfa4}{strlen}(buf);
352 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!is\+\_\+conversion\+\_\+specifier@{is\+\_\+conversion\+\_\+specifier}}
\index{is\+\_\+conversion\+\_\+specifier@{is\+\_\+conversion\+\_\+specifier}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{is\+\_\+conversion\+\_\+specifier(char c)}{is_conversion_specifier(char c)}}]{\setlength{\rightskip}{0pt plus 5cm}char is\+\_\+conversion\+\_\+specifier (
\begin{DoxyParamCaption}
\item[{char}]{c}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_aca5e96bcd4ba56fb4d7ac75160f2161c}{}\label{string_8h_aca5e96bcd4ba56fb4d7ac75160f2161c}


is\+\_\+conversion\+\_\+specifier checks to see if the character is one of the standard printf formats 


\begin{DoxyParams}{Parameters}
{\em c} & character to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns the character if the character is a format specifier, else returns 0 
\end{DoxyReturn}


Definition at line 359 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+().


\begin{DoxyCode}
360 \{
361     \textcolor{keywordflow}{switch}(c)
362     \{
363         \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}: 
364         \textcolor{keywordflow}{case} \textcolor{charliteral}{'s'}: 
365         \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'}: 
366         \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'o'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'X'}: 
367         \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'}: \textcolor{keywordflow}{case}\textcolor{charliteral}{'A'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'g'}: \textcolor{keywordflow}{case} \textcolor{charliteral}{'G'}:
368         \textcolor{keywordflow}{case} \textcolor{charliteral}{'p'}: 
369             \textcolor{keywordflow}{return} c; 
370         
371         \textcolor{keywordflow}{default}: \textcolor{keywordflow}{return} 0;
372     \}
373     \textcolor{keywordflow}{return} 0;
374 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!isnum@{isnum}}
\index{isnum@{isnum}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{isnum(const char c)}{isnum(const char c)}}]{\setlength{\rightskip}{0pt plus 5cm}int isnum (
\begin{DoxyParamCaption}
\item[{const char}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{string_8h_a1153bdbe1c0758a66d46bdefa2eb755d}{}\label{string_8h_a1153bdbe1c0758a66d46bdefa2eb755d}


isnum inline helper function to check if a character is represents an ascii number 


\begin{DoxyParams}{Parameters}
{\em c} & character to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns 1 if the character is an ascii number, else returns 0 
\end{DoxyReturn}


Definition at line 381 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+().


\begin{DoxyCode}
382 \{
383    \textcolor{keywordflow}{return} ((c >= \textcolor{charliteral}{'0'}) && (c <= \textcolor{charliteral}{'9'}));
384 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!isspace@{isspace}}
\index{isspace@{isspace}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{isspace(const char $\ast$c)}{isspace(const char *c)}}]{\setlength{\rightskip}{0pt plus 5cm}int isspace (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{c}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a0f3d37d605e9e6d4fc1853ff9d4b91bf}{}\label{string_8h_a0f3d37d605e9e6d4fc1853ff9d4b91bf}


isspace Determines if a character is a whitespace. 


\begin{DoxyParams}{Parameters}
{\em c} & character to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if it is a whitespace, 0 if it is not a whitespace. 
\end{DoxyReturn}


Definition at line 110 of file string.\+c.


\begin{DoxyCode}
111 \{
112   \textcolor{keywordflow}{if} (*c == \textcolor{charliteral}{' '}  ||
113       *c == \textcolor{charliteral}{'\(\backslash\)n'} ||
114       *c == \textcolor{charliteral}{'\(\backslash\)r'} ||
115       *c == \textcolor{charliteral}{'\(\backslash\)f'} ||
116       *c == \textcolor{charliteral}{'\(\backslash\)t'} ||
117       *c == \textcolor{charliteral}{'\(\backslash\)v'})\{
118     \textcolor{keywordflow}{return} 1;
119   \}
120   \textcolor{keywordflow}{return} 0;
121 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!memset@{memset}}
\index{memset@{memset}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{memset(void $\ast$s, int c, size\+\_\+t n)}{memset(void *s, int c, size_t n)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ memset (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{s, }
\item[{int}]{c, }
\item[{{\bf size\+\_\+t}}]{n}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_ace6ee45c30e71865e6eb635200379db9}{}\label{string_8h_ace6ee45c30e71865e6eb635200379db9}


memset Set a region of memory. 


\begin{DoxyParams}{Parameters}
{\em s} & destination. \\
\hline
{\em c} & byte to write. \\
\hline
{\em n} & count. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}


Definition at line 135 of file string.\+c.



Referenced by init\+\_\+idt(), and init\+\_\+paging().


\begin{DoxyCode}
136 \{
137   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) s;
138   \textcolor{keywordflow}{while}(n--)\{
139     *p++ = (\textcolor{keywordtype}{unsigned} char) c;
140   \}
141   \textcolor{keywordflow}{return} s;
142 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!sprintf@{sprintf}}
\index{sprintf@{sprintf}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{sprintf(char $\ast$str, int buf\+Length, const char $\ast$format,...) \+\_\+\+\_\+attribute\+\_\+\+\_\+((format(printf}{sprintf(char *str, int bufLength, const char *format,...) __attribute__((format(printf}}]{\setlength{\rightskip}{0pt plus 5cm}int sprintf (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str, }
\item[{int}]{buf\+Length, }
\item[{const char $\ast$}]{format, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_ae9cac82f3293a00d8ec8705a3fc5cf64}{}\label{string_8h_ae9cac82f3293a00d8ec8705a3fc5cf64}


sprintf print with format to specified string buffer 


\begin{DoxyParams}{Parameters}
{\em str} & a char $\ast$, place where the built string will be placed \\
\hline
{\em buf\+Length} & the size of the buffer of the char $\ast$, string writing will not exceed this value \\
\hline
{\em format} & a format string confirming to the std library format \\
\hline
{\em ...} & any number of parameters that will be printed according to the format. if wrong type is specified, behavior is undefined \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of characters placed in the output buffer 
\end{DoxyReturn}


Referenced by get\+Time(), kmain(), pcb\+Test(), and shutdown\+Func().

\index{string.\+h@{string.\+h}!strcat@{strcat}}
\index{strcat@{strcat}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{strcat(char $\ast$s1, const char $\ast$s2)}{strcat(char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ strcat (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a8908188ae9fc2f05d993257ef001d553}{}\label{string_8h_a8908188ae9fc2f05d993257ef001d553}


strcat concatenates the contents of one string onto another. 


\begin{DoxyParams}{Parameters}
{\em s1} & destination string. \\
\hline
{\em s2} & source string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The combined string s1 and s2. 
\end{DoxyReturn}


Definition at line 97 of file string.\+c.



Referenced by klogv(), kmain(), and kpanic().


\begin{DoxyCode}
98 \{
99   \textcolor{keywordtype}{char} *rc = s1;
100   \textcolor{keywordflow}{if} (*s1) \textcolor{keywordflow}{while}(*++s1);
101   \textcolor{keywordflow}{while}( (*s1++ = *s2++) );
102   \textcolor{keywordflow}{return} rc;
103 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!strcmp@{strcmp}}
\index{strcmp@{strcmp}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{strcmp(const char $\ast$s1, const char $\ast$s2)}{strcmp(const char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}int strcmp (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a11bd144d7d44914099a3aeddf1c8567d}{}\label{string_8h_a11bd144d7d44914099a3aeddf1c8567d}


strcmp compares two strings. 


\begin{DoxyParams}{Parameters}
{\em s1} & string 1 to compare. \\
\hline
{\em s2} & string 2 to compare. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
if the two strings are equal. If they are equal it will return 0, otherwise will return a non-\/zero integer. 
\end{DoxyReturn}


Definition at line 73 of file string.\+c.



Referenced by date(), exec\+\_\+comm(), help\+Date(), help\+Func(), help\+Time(), is\+Empty(), pcb\+Func(), pcb\+Search\+Func(), searchcomp\+Function(), string\+To\+Class(), and time().


\begin{DoxyCode}
74 \{
75 
76   \textcolor{comment}{// Remarks:}
77   \textcolor{comment}{// 1) If we made it to the end of both strings (i. e. our pointer points to a}
78   \textcolor{comment}{//    '\(\backslash\)0' character), the function will return 0}
79   \textcolor{comment}{// 2) If we didn't make it to the end of both strings, the function will}
80   \textcolor{comment}{//    return the difference of the characters at the first index of}
81   \textcolor{comment}{//    indifference.}
82   \textcolor{keywordtype}{int} i = 0;
83   \textcolor{keywordflow}{for}(; (s1[i]) && (s2[i]) && (s1[i]==s2[i]); i++)
84   \{
85   \}
86   
87   \textcolor{keywordflow}{return} s1[i]-s2[i];
88 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!strcpy@{strcpy}}
\index{strcpy@{strcpy}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{strcpy(char $\ast$s1, const char $\ast$s2)}{strcpy(char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ strcpy (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a1eb9cae61e6a6282c28dbc298ef7297e}{}\label{string_8h_a1eb9cae61e6a6282c28dbc298ef7297e}


strcpy copies one string to another string 


\begin{DoxyParams}{Parameters}
{\em s1} & destination string. Character pointer to a string. \\
\hline
{\em s2} & source string. Character pointer to a string. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return s1. 
\end{DoxyReturn}


Definition at line 26 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+(), init\+\_\+commhand(), parse\+\_\+comm(), serial\+\_\+poll(), and setup\+P\+C\+B().


\begin{DoxyCode}
27 \{
28   \textcolor{keywordflow}{while}(*s2 != \textcolor{charliteral}{'\(\backslash\)0'}) \{
29       *s1 = *s2;
30       s1++;
31       s2++;
32    \}
33    \textcolor{keywordflow}{if}(*s2 == \textcolor{charliteral}{'\(\backslash\)0'}) \{
34       
35       *s1 = *s2;
36    \}
37   \textcolor{keywordflow}{return} s1; \textcolor{comment}{// return pointer to destination string}
38 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!strlen@{strlen}}
\index{strlen@{strlen}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{strlen(const char $\ast$s)}{strlen(const char *s)}}]{\setlength{\rightskip}{0pt plus 5cm}int strlen (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_a2dee044e4e667b5b789b493abd21cfa4}{}\label{string_8h_a2dee044e4e667b5b789b493abd21cfa4}


strlen returns the length of a string 


\begin{DoxyParams}{Parameters}
{\em s} & character pointer to a string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the length of the string 
\end{DoxyReturn}


Definition at line 10 of file string.\+c.



Referenced by \+\_\+\+\_\+attribute\+\_\+\+\_\+(), help\+Date(), help\+Time(), int\+To\+S(), set\+Date(), set\+Time(), and setup\+P\+C\+B().


\begin{DoxyCode}
11 \{
12    \textcolor{keywordtype}{int} length = 0;
13    \textcolor{keywordflow}{while}(s[length] != \textcolor{charliteral}{'\(\backslash\)0'}) \{
14     length++;
15    \}
16    length++;
17   \textcolor{keywordflow}{return} length; \textcolor{comment}{// return length of string}
18 \}
\end{DoxyCode}
\index{string.\+h@{string.\+h}!strtok@{strtok}}
\index{strtok@{strtok}!string.\+h@{string.\+h}}
\subsubsection[{\texorpdfstring{strtok(char $\ast$s1, const char $\ast$s2)}{strtok(char *s1, const char *s2)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ strtok (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{s1, }
\item[{const char $\ast$}]{s2}
\end{DoxyParamCaption}
)}\hypertarget{string_8h_af1a867dcea42fc1215d0eddf19283ef3}{}\label{string_8h_af1a867dcea42fc1215d0eddf19283ef3}


strtok Split string into tokens. 


\begin{DoxyParams}{Parameters}
{\em s1} & String to split \\
\hline
{\em s2} & Delimeter. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
String split into delimeters. 
\end{DoxyReturn}


Definition at line 150 of file string.\+c.



References N\+U\+LL.



Referenced by parse\+\_\+comm().


\begin{DoxyCode}
151 \{
152   \textcolor{keyword}{static} \textcolor{keywordtype}{char} *tok\_tmp = \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
153   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *p = s2;
154 
155   \textcolor{comment}{//new string}
156   \textcolor{keywordflow}{if} (s1!=\hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})\{
157     tok\_tmp = s1;
158   \}
159   \textcolor{comment}{//old string cont'd}
160   \textcolor{keywordflow}{else} \{
161     \textcolor{keywordflow}{if} (tok\_tmp==\hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL})\{
162       \textcolor{keywordflow}{return} \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
163     \}
164     s1 = tok\_tmp;
165   \}
166 
167   \textcolor{comment}{//skip leading s2 characters}
168   \textcolor{keywordflow}{while} ( *p && *s1 )\{
169     \textcolor{keywordflow}{if} (*s1==*p)\{
170       ++s1;
171       p = s2;
172       \textcolor{keywordflow}{continue};
173     \}
174     ++p;
175   \}
176 
177   \textcolor{comment}{//no more to parse}
178   \textcolor{keywordflow}{if} (!*s1)\{
179     \textcolor{keywordflow}{return} (tok\_tmp = \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL});
180   \}
181 
182   \textcolor{comment}{//skip non-s2 characters}
183   tok\_tmp = s1;
184   \textcolor{keywordflow}{while} (*tok\_tmp)\{
185     p = s2;
186     \textcolor{keywordflow}{while} (*p)\{
187       \textcolor{keywordflow}{if} (*tok\_tmp==*p++)\{
188     *tok\_tmp++ = \textcolor{charliteral}{'\(\backslash\)0'};
189     \textcolor{keywordflow}{return} s1;
190       \}
191     \}
192     ++tok\_tmp;
193   \}
194 
195   \textcolor{comment}{//end of string}
196   tok\_tmp = \hyperlink{system_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL};
197   \textcolor{keywordflow}{return} s1;
198 \}
\end{DoxyCode}
